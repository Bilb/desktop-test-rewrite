"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = __importStar(require("sinon"));
const crypto = __importStar(require("crypto"));
const uuid_1 = require("uuid");
const types_1 = require("../../../ts/session/types");
const outgoing_1 = require("../../session/messages/outgoing");
const _1 = require(".");
const globalAny = global;
const sandbox = sinon.createSandbox();
// We have to do this in a weird way because Data uses module.exports
//  which doesn't play well with sinon or ImportMock
// tslint:disable-next-line: no-require-imports no-var-requires
const Data = require('../../../js/modules/data');
/**
 * Stub a function inside Data.
 *
 * Note: This uses a custom sandbox.
 * Please call `restoreStubs()` or `stub.restore()` to restore original functionality.
 */
function stubData(fn) {
    return sandbox.stub(Data, fn);
}
exports.stubData = stubData;
/**
 * Stub a window object.
 *
 * Note: This uses a custom sandbox.
 * Please call `restoreStubs()` or `stub.restore()` to restore original functionality.
 */
function stubWindow(fn, value) {
    // tslint:disable-next-line: no-typeof-undefined
    if (typeof globalAny.window === 'undefined') {
        globalAny.window = {};
    }
    const set = (newValue) => {
        globalAny.window[fn] = newValue;
    };
    const get = () => {
        return globalAny.window[fn];
    };
    globalAny.window[fn] = value;
    return {
        get,
        set,
    };
}
exports.stubWindow = stubWindow;
function restoreStubs() {
    globalAny.window = undefined;
    sandbox.restore();
}
exports.restoreStubs = restoreStubs;
function generateFakePubKey() {
    // Generates a mock pubkey for testing
    const numBytes = types_1.PubKey.PUBKEY_LEN / 2 - 1;
    const hexBuffer = crypto.randomBytes(numBytes).toString('hex');
    const pubkeyString = `05${hexBuffer}`;
    return new types_1.PubKey(pubkeyString);
}
exports.generateFakePubKey = generateFakePubKey;
function generateFakePubKeys(amount) {
    const numPubKeys = amount > 0 ? Math.floor(amount) : 0;
    // tslint:disable-next-line: no-unnecessary-callback-wrapper
    return new Array(numPubKeys).fill(0).map(() => generateFakePubKey());
}
exports.generateFakePubKeys = generateFakePubKeys;
function generateChatMessage(identifier) {
    return new outgoing_1.ChatMessage({
        body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit',
        identifier: (identifier !== null && identifier !== void 0 ? identifier : uuid_1.v4()),
        timestamp: Date.now(),
        attachments: undefined,
        quote: undefined,
        expireTimer: undefined,
        lokiProfile: undefined,
        preview: undefined,
    });
}
exports.generateChatMessage = generateChatMessage;
function generateOpenGroupMessage() {
    const group = new types_1.OpenGroup({
        server: 'chat.example.server',
        channel: 0,
        conversationId: '0',
    });
    return new outgoing_1.OpenGroupMessage({
        timestamp: Date.now(),
        group,
        attachments: undefined,
        preview: undefined,
        body: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit',
        quote: undefined,
    });
}
exports.generateOpenGroupMessage = generateOpenGroupMessage;
function generateClosedGroupMessage(groupId) {
    return new outgoing_1.ClosedGroupChatMessage({
        identifier: uuid_1.v4(),
        groupId: (groupId !== null && groupId !== void 0 ? groupId : generateFakePubKey().key),
        chatMessage: generateChatMessage(),
    });
}
exports.generateClosedGroupMessage = generateClosedGroupMessage;
class MockPrivateConversation {
    constructor(params) {
        var _a;
        const dayInSeconds = 86400;
        this.isPrimary = params.isPrimary;
        this.id = (_a = params.id, (_a !== null && _a !== void 0 ? _a : _1.TestUtils.generateFakePubKey().key));
        this.attributes = {
            members: [],
            left: false,
            expireTimer: dayInSeconds,
            profileSharing: true,
            mentionedUs: false,
            unreadCount: 99,
            isArchived: false,
            active_at: Date.now(),
            timestamp: Date.now(),
            secondaryStatus: !this.isPrimary,
        };
    }
    isPrivate() {
        return true;
    }
    isOurLocalDevice() {
        return false;
    }
    isBlocked() {
        return false;
    }
    getPrimaryDevicePubKey() {
        return this.isPrimary ? this.id : _1.TestUtils.generateFakePubKey().key;
    }
}
exports.MockPrivateConversation = MockPrivateConversation;
//# sourceMappingURL=testUtils.js.map