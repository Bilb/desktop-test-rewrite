var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var import_chai = __toESM(require("chai"));
var crypto = __toESM(require("crypto"));
var sinon = __toESM(require("sinon"));
var import_crypto = require("../../../../session/crypto");
var import_EncryptionType = require("../../../../session/types/EncryptionType");
var import_test_utils = require("../../../test-utils");
var import_protobuf = require("../../../../protobuf");
var import_utils = require("../../../../session/utils");
var import_chai_bytes = __toESM(require("chai-bytes"));
var import_types = require("../../../../session/types");
var import_String = require("../../../../session/utils/String");
var import_BufferPadding = require("../../../../session/crypto/BufferPadding");
import_chai.default.use(import_chai_bytes.default);
describe("MessageEncrypter", () => {
  const sandbox = sinon.createSandbox();
  const ourNumber = "0123456789abcdef";
  const ourUserEd25516Keypair = {
    pubKey: "37e1631b002de498caf7c5c1712718bde7f257c6dadeed0c21abf5e939e6c309",
    privKey: "be1d11154ff9b6de77873f0b6b0bcc460000000000000000000000000000000037e1631b002de498caf7c5c1712718bde7f257c6dadeed0c21abf5e939e6c309"
  };
  const ourIdentityKeypair = {
    pubKey: new Uint8Array([
      5,
      44,
      2,
      168,
      162,
      203,
      50,
      66,
      136,
      81,
      30,
      221,
      57,
      245,
      1,
      148,
      162,
      194,
      255,
      47,
      134,
      104,
      180,
      207,
      188,
      18,
      71,
      62,
      58,
      107,
      23,
      92,
      97
    ]),
    privKey: new Uint8Array([
      200,
      45,
      226,
      75,
      253,
      235,
      213,
      108,
      187,
      188,
      217,
      9,
      51,
      105,
      65,
      15,
      97,
      36,
      233,
      33,
      21,
      31,
      7,
      90,
      145,
      30,
      52,
      254,
      47,
      162,
      192,
      105
    ])
  };
  beforeEach(() => {
    sandbox.stub(import_utils.UserUtils, "getOurPubKeyStrFromCache").returns(ourNumber);
    sandbox.stub(import_utils.UserUtils, "getUserED25519KeyPair").resolves(ourUserEd25516Keypair);
  });
  afterEach(() => {
    sandbox.restore();
    import_test_utils.TestUtils.restoreStubs();
  });
  describe("EncryptionType", () => {
    describe("ClosedGroup", () => {
      it("should return a CLOSED_GROUP_MESSAGE envelope type for ClosedGroup", async () => {
        const hexKeyPair = {
          publicHex: `05${ourUserEd25516Keypair.pubKey}`,
          privateHex: "0123456789abcdef"
        };
        import_test_utils.TestUtils.stubData("getLatestClosedGroupEncryptionKeyPair").resolves(hexKeyPair);
        const data = crypto.randomBytes(10);
        const result = await import_crypto.MessageEncrypter.encrypt(import_test_utils.TestUtils.generateFakePubKey(), data, import_EncryptionType.EncryptionType.ClosedGroup);
        import_chai.default.expect(result.envelopeType).to.deep.equal(import_protobuf.SignalService.Envelope.Type.CLOSED_GROUP_MESSAGE);
      });
      it("should return a SESSION_MESSAGE envelope type for Fallback", async () => {
        const data = crypto.randomBytes(10);
        const result = await import_crypto.MessageEncrypter.encrypt(import_test_utils.TestUtils.generateFakePubKey(), data, import_EncryptionType.EncryptionType.Fallback);
        import_chai.default.expect(result.envelopeType).to.deep.equal(import_protobuf.SignalService.Envelope.Type.SESSION_MESSAGE);
      });
      it("should throw an error for anything else than Fallback or ClosedGroup", () => {
        const data = crypto.randomBytes(10);
        return import_crypto.MessageEncrypter.encrypt(import_test_utils.TestUtils.generateFakePubKey(), data, import_EncryptionType.EncryptionType.Signal).should.eventually.be.rejectedWith(Error);
      });
    });
  });
  describe("Session Protocol", () => {
    let sandboxSessionProtocol;
    beforeEach(() => {
      sandboxSessionProtocol = sinon.createSandbox();
      sandboxSessionProtocol.stub(import_utils.UserUtils, "getIdentityKeyPair").resolves(ourIdentityKeypair);
    });
    afterEach(() => {
      sandboxSessionProtocol.restore();
    });
    it("should pass the padded message body to encrypt", async () => {
      const data = crypto.randomBytes(10);
      const spy = sinon.spy(import_crypto.MessageEncrypter, "encryptUsingSessionProtocol");
      await import_crypto.MessageEncrypter.encrypt(import_test_utils.TestUtils.generateFakePubKey(), data, import_EncryptionType.EncryptionType.Fallback);
      import_chai.default.expect(spy.callCount).to.be.equal(1);
      const paddedData = (0, import_BufferPadding.addMessagePadding)(data);
      const firstArgument = new Uint8Array(spy.args[0][1]);
      import_chai.default.expect(firstArgument).to.deep.equal(paddedData);
      spy.restore();
    });
    it("should pass the correct data for sodium crypto_sign", async () => {
      const keypair = await import_utils.UserUtils.getUserED25519KeyPair();
      const recipient = import_test_utils.TestUtils.generateFakePubKey();
      const sodium = await (0, import_crypto.getSodium)();
      const cryptoSignDetachedSpy = sandboxSessionProtocol.spy(sodium, "crypto_sign_detached");
      const plainText = "123456";
      const plainTextBytes = new Uint8Array(import_utils.StringUtils.encode(plainText, "utf8"));
      const userED25519PubKeyBytes = new Uint8Array(import_utils.StringUtils.fromHex(keypair.pubKey));
      const recipientX25519PublicKeyWithoutPrefix = import_types.PubKey.remove05PrefixIfNeeded(recipient.key);
      const recipientX25519PublicKey = new Uint8Array(import_utils.StringUtils.fromHex(recipientX25519PublicKeyWithoutPrefix));
      await import_crypto.MessageEncrypter.encryptUsingSessionProtocol(recipient, plainTextBytes);
      const [dataForSign, userED25519SecretKeyBytes] = cryptoSignDetachedSpy.args[0];
      const userEdPrivkeyBytes = new Uint8Array(import_utils.StringUtils.fromHex(keypair.privKey));
      (0, import_chai.expect)(userED25519SecretKeyBytes).to.equalBytes(userEdPrivkeyBytes);
      (0, import_chai.expect)(dataForSign.subarray(0, plainTextBytes.length)).to.equalBytes(plainTextBytes);
      (0, import_chai.expect)(dataForSign.subarray(plainTextBytes.length, plainTextBytes.length + userED25519PubKeyBytes.length)).to.equalBytes(userED25519PubKeyBytes);
      (0, import_chai.expect)(dataForSign.subarray(plainTextBytes.length + userED25519PubKeyBytes.length)).to.equalBytes(recipientX25519PublicKey);
    });
    it("should return valid decodable ciphertext", async () => {
      const userX25519KeyPair = await import_utils.UserUtils.getIdentityKeyPair();
      const userEd25519KeyPair = await import_utils.UserUtils.getUserED25519KeyPair();
      const plainTextBytes = new Uint8Array(import_utils.StringUtils.encode("123456789", "utf8"));
      const sodium = await (0, import_crypto.getSodium)();
      const recipientX25519PrivateKey = userX25519KeyPair.privKey;
      const recipientX25519PublicKeyHex = (0, import_String.toHex)(userX25519KeyPair.pubKey);
      const recipientX25519PublicKeyWithoutPrefix = import_types.PubKey.remove05PrefixIfNeeded(recipientX25519PublicKeyHex);
      const recipientX25519PublicKey = new import_types.PubKey(recipientX25519PublicKeyWithoutPrefix);
      const ciphertext = await import_crypto.MessageEncrypter.encryptUsingSessionProtocol(recipientX25519PublicKey, plainTextBytes);
      const plaintextWithMetadata = sodium.crypto_box_seal_open(ciphertext, new Uint8Array((0, import_String.fromHex)(recipientX25519PublicKey.key)), new Uint8Array(recipientX25519PrivateKey));
      const signatureSize = sodium.crypto_sign_BYTES;
      const ed25519PublicKeySize = sodium.crypto_sign_PUBLICKEYBYTES;
      const signatureStart = plaintextWithMetadata.byteLength - signatureSize;
      const signature = plaintextWithMetadata.subarray(signatureStart);
      const pubkeyStart = plaintextWithMetadata.byteLength - (signatureSize + ed25519PublicKeySize);
      const pubkeyEnd = plaintextWithMetadata.byteLength - signatureSize;
      const senderED25519PublicKey = plaintextWithMetadata.subarray(pubkeyStart, pubkeyEnd);
      const plainTextEnd = plaintextWithMetadata.byteLength - (signatureSize + ed25519PublicKeySize);
      const plaintextDecoded = plaintextWithMetadata.subarray(0, plainTextEnd);
      (0, import_chai.expect)(plaintextDecoded).to.equalBytes(plainTextBytes);
      (0, import_chai.expect)(senderED25519PublicKey).to.equalBytes(userEd25519KeyPair.pubKey);
      const dataForVerify = (0, import_crypto.concatUInt8Array)(plaintextDecoded, senderED25519PublicKey, new Uint8Array((0, import_String.fromHex)(recipientX25519PublicKey.key)));
      const isValid = sodium.crypto_sign_verify_detached(signature, dataForVerify, senderED25519PublicKey);
      (0, import_chai.expect)(isValid).to.be.equal(true, "the signature cannot be verified");
    });
  });
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vLi4vdHMvdGVzdC9zZXNzaW9uL3VuaXQvY3J5cHRvL01lc3NhZ2VFbmNyeXB0ZXJfdGVzdC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IGNoYWksIHsgZXhwZWN0IH0gZnJvbSAnY2hhaSc7XG5pbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIHNpbm9uIGZyb20gJ3Npbm9uJztcbmltcG9ydCB7IGNvbmNhdFVJbnQ4QXJyYXksIGdldFNvZGl1bSwgTWVzc2FnZUVuY3J5cHRlciB9IGZyb20gJy4uLy4uLy4uLy4uL3Nlc3Npb24vY3J5cHRvJztcbmltcG9ydCB7IEVuY3J5cHRpb25UeXBlIH0gZnJvbSAnLi4vLi4vLi4vLi4vc2Vzc2lvbi90eXBlcy9FbmNyeXB0aW9uVHlwZSc7XG5pbXBvcnQgeyBUZXN0VXRpbHMgfSBmcm9tICcuLi8uLi8uLi90ZXN0LXV0aWxzJztcbmltcG9ydCB7IFNpZ25hbFNlcnZpY2UgfSBmcm9tICcuLi8uLi8uLi8uLi9wcm90b2J1Zic7XG5cbmltcG9ydCB7IFN0cmluZ1V0aWxzLCBVc2VyVXRpbHMgfSBmcm9tICcuLi8uLi8uLi8uLi9zZXNzaW9uL3V0aWxzJztcblxuaW1wb3J0IGNoYWlCeXRlcyBmcm9tICdjaGFpLWJ5dGVzJztcbmltcG9ydCB7IFB1YktleSB9IGZyb20gJy4uLy4uLy4uLy4uL3Nlc3Npb24vdHlwZXMnO1xuaW1wb3J0IHsgZnJvbUhleCwgdG9IZXggfSBmcm9tICcuLi8uLi8uLi8uLi9zZXNzaW9uL3V0aWxzL1N0cmluZyc7XG5pbXBvcnQgeyBhZGRNZXNzYWdlUGFkZGluZyB9IGZyb20gJy4uLy4uLy4uLy4uL3Nlc3Npb24vY3J5cHRvL0J1ZmZlclBhZGRpbmcnO1xuXG5jaGFpLnVzZShjaGFpQnl0ZXMpO1xuXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1mdW5jLWJvZHktbGVuZ3RoXG5kZXNjcmliZSgnTWVzc2FnZUVuY3J5cHRlcicsICgpID0+IHtcbiAgY29uc3Qgc2FuZGJveCA9IHNpbm9uLmNyZWF0ZVNhbmRib3goKTtcbiAgY29uc3Qgb3VyTnVtYmVyID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICBjb25zdCBvdXJVc2VyRWQyNTUxNktleXBhaXIgPSB7XG4gICAgcHViS2V5OiAnMzdlMTYzMWIwMDJkZTQ5OGNhZjdjNWMxNzEyNzE4YmRlN2YyNTdjNmRhZGVlZDBjMjFhYmY1ZTkzOWU2YzMwOScsXG4gICAgcHJpdktleTpcbiAgICAgICdiZTFkMTExNTRmZjliNmRlNzc4NzNmMGI2YjBiY2M0NjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMzdlMTYzMWIwMDJkZTQ5OGNhZjdjNWMxNzEyNzE4YmRlN2YyNTdjNmRhZGVlZDBjMjFhYmY1ZTkzOWU2YzMwOScsXG4gIH07XG5cbiAgY29uc3Qgb3VySWRlbnRpdHlLZXlwYWlyID0ge1xuICAgIHB1YktleTogbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgNSxcbiAgICAgIDQ0LFxuICAgICAgMixcbiAgICAgIDE2OCxcbiAgICAgIDE2MixcbiAgICAgIDIwMyxcbiAgICAgIDUwLFxuICAgICAgNjYsXG4gICAgICAxMzYsXG4gICAgICA4MSxcbiAgICAgIDMwLFxuICAgICAgMjIxLFxuICAgICAgNTcsXG4gICAgICAyNDUsXG4gICAgICAxLFxuICAgICAgMTQ4LFxuICAgICAgMTYyLFxuICAgICAgMTk0LFxuICAgICAgMjU1LFxuICAgICAgNDcsXG4gICAgICAxMzQsXG4gICAgICAxMDQsXG4gICAgICAxODAsXG4gICAgICAyMDcsXG4gICAgICAxODgsXG4gICAgICAxOCxcbiAgICAgIDcxLFxuICAgICAgNjIsXG4gICAgICA1OCxcbiAgICAgIDEwNyxcbiAgICAgIDIzLFxuICAgICAgOTIsXG4gICAgICA5NyxcbiAgICBdKSxcbiAgICBwcml2S2V5OiBuZXcgVWludDhBcnJheShbXG4gICAgICAyMDAsXG4gICAgICA0NSxcbiAgICAgIDIyNixcbiAgICAgIDc1LFxuICAgICAgMjUzLFxuICAgICAgMjM1LFxuICAgICAgMjEzLFxuICAgICAgMTA4LFxuICAgICAgMTg3LFxuICAgICAgMTg4LFxuICAgICAgMjE3LFxuICAgICAgOSxcbiAgICAgIDUxLFxuICAgICAgMTA1LFxuICAgICAgNjUsXG4gICAgICAxNSxcbiAgICAgIDk3LFxuICAgICAgMzYsXG4gICAgICAyMzMsXG4gICAgICAzMyxcbiAgICAgIDIxLFxuICAgICAgMzEsXG4gICAgICA3LFxuICAgICAgOTAsXG4gICAgICAxNDUsXG4gICAgICAzMCxcbiAgICAgIDUyLFxuICAgICAgMjU0LFxuICAgICAgNDcsXG4gICAgICAxNjIsXG4gICAgICAxOTIsXG4gICAgICAxMDUsXG4gICAgXSksXG4gIH07XG5cbiAgYmVmb3JlRWFjaCgoKSA9PiB7XG4gICAgc2FuZGJveC5zdHViKFVzZXJVdGlscywgJ2dldE91clB1YktleVN0ckZyb21DYWNoZScpLnJldHVybnMob3VyTnVtYmVyKTtcbiAgICBzYW5kYm94LnN0dWIoVXNlclV0aWxzLCAnZ2V0VXNlckVEMjU1MTlLZXlQYWlyJykucmVzb2x2ZXMob3VyVXNlckVkMjU1MTZLZXlwYWlyKTtcbiAgfSk7XG5cbiAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICBzYW5kYm94LnJlc3RvcmUoKTtcbiAgICBUZXN0VXRpbHMucmVzdG9yZVN0dWJzKCk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdFbmNyeXB0aW9uVHlwZScsICgpID0+IHtcbiAgICBkZXNjcmliZSgnQ2xvc2VkR3JvdXAnLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBhIENMT1NFRF9HUk9VUF9NRVNTQUdFIGVudmVsb3BlIHR5cGUgZm9yIENsb3NlZEdyb3VwJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBoZXhLZXlQYWlyID0ge1xuICAgICAgICAgIHB1YmxpY0hleDogYDA1JHtvdXJVc2VyRWQyNTUxNktleXBhaXIucHViS2V5fWAsXG4gICAgICAgICAgcHJpdmF0ZUhleDogJzAxMjM0NTY3ODlhYmNkZWYnLFxuICAgICAgICB9O1xuXG4gICAgICAgIFRlc3RVdGlscy5zdHViRGF0YSgnZ2V0TGF0ZXN0Q2xvc2VkR3JvdXBFbmNyeXB0aW9uS2V5UGFpcicpLnJlc29sdmVzKGhleEtleVBhaXIpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTApO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IE1lc3NhZ2VFbmNyeXB0ZXIuZW5jcnlwdChcbiAgICAgICAgICBUZXN0VXRpbHMuZ2VuZXJhdGVGYWtlUHViS2V5KCksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBFbmNyeXB0aW9uVHlwZS5DbG9zZWRHcm91cFxuICAgICAgICApO1xuICAgICAgICBjaGFpXG4gICAgICAgICAgLmV4cGVjdChyZXN1bHQuZW52ZWxvcGVUeXBlKVxuICAgICAgICAgIC50by5kZWVwLmVxdWFsKFNpZ25hbFNlcnZpY2UuRW52ZWxvcGUuVHlwZS5DTE9TRURfR1JPVVBfTUVTU0FHRSk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYSBTRVNTSU9OX01FU1NBR0UgZW52ZWxvcGUgdHlwZSBmb3IgRmFsbGJhY2snLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMTApO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IE1lc3NhZ2VFbmNyeXB0ZXIuZW5jcnlwdChcbiAgICAgICAgICBUZXN0VXRpbHMuZ2VuZXJhdGVGYWtlUHViS2V5KCksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBFbmNyeXB0aW9uVHlwZS5GYWxsYmFja1xuICAgICAgICApO1xuICAgICAgICBjaGFpLmV4cGVjdChyZXN1bHQuZW52ZWxvcGVUeXBlKS50by5kZWVwLmVxdWFsKFNpZ25hbFNlcnZpY2UuRW52ZWxvcGUuVHlwZS5TRVNTSU9OX01FU1NBR0UpO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdGhyb3cgYW4gZXJyb3IgZm9yIGFueXRoaW5nIGVsc2UgdGhhbiBGYWxsYmFjayBvciBDbG9zZWRHcm91cCcsICgpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGNyeXB0by5yYW5kb21CeXRlcygxMCk7XG4gICAgICAgIHJldHVybiBNZXNzYWdlRW5jcnlwdGVyLmVuY3J5cHQoXG4gICAgICAgICAgVGVzdFV0aWxzLmdlbmVyYXRlRmFrZVB1YktleSgpLFxuICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgRW5jcnlwdGlvblR5cGUuU2lnbmFsXG4gICAgICAgICkuc2hvdWxkLmV2ZW50dWFsbHkuYmUucmVqZWN0ZWRXaXRoKEVycm9yKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG1heC1mdW5jLWJvZHktbGVuZ3RoXG4gIGRlc2NyaWJlKCdTZXNzaW9uIFByb3RvY29sJywgKCkgPT4ge1xuICAgIGxldCBzYW5kYm94U2Vzc2lvblByb3RvY29sOiBzaW5vbi5TaW5vblNhbmRib3g7XG5cbiAgICBiZWZvcmVFYWNoKCgpID0+IHtcbiAgICAgIHNhbmRib3hTZXNzaW9uUHJvdG9jb2wgPSBzaW5vbi5jcmVhdGVTYW5kYm94KCk7XG5cbiAgICAgIHNhbmRib3hTZXNzaW9uUHJvdG9jb2wuc3R1YihVc2VyVXRpbHMsICdnZXRJZGVudGl0eUtleVBhaXInKS5yZXNvbHZlcyhvdXJJZGVudGl0eUtleXBhaXIpO1xuICAgIH0pO1xuXG4gICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgIHNhbmRib3hTZXNzaW9uUHJvdG9jb2wucmVzdG9yZSgpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBwYXNzIHRoZSBwYWRkZWQgbWVzc2FnZSBib2R5IHRvIGVuY3J5cHQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKDEwKTtcbiAgICAgIGNvbnN0IHNweSA9IHNpbm9uLnNweShNZXNzYWdlRW5jcnlwdGVyLCAnZW5jcnlwdFVzaW5nU2Vzc2lvblByb3RvY29sJyk7XG4gICAgICBhd2FpdCBNZXNzYWdlRW5jcnlwdGVyLmVuY3J5cHQoVGVzdFV0aWxzLmdlbmVyYXRlRmFrZVB1YktleSgpLCBkYXRhLCBFbmNyeXB0aW9uVHlwZS5GYWxsYmFjayk7XG4gICAgICBjaGFpLmV4cGVjdChzcHkuY2FsbENvdW50KS50by5iZS5lcXVhbCgxKTtcbiAgICAgIGNvbnN0IHBhZGRlZERhdGEgPSBhZGRNZXNzYWdlUGFkZGluZyhkYXRhKTtcbiAgICAgIGNvbnN0IGZpcnN0QXJndW1lbnQgPSBuZXcgVWludDhBcnJheShzcHkuYXJnc1swXVsxXSk7XG4gICAgICBjaGFpLmV4cGVjdChmaXJzdEFyZ3VtZW50KS50by5kZWVwLmVxdWFsKHBhZGRlZERhdGEpO1xuICAgICAgc3B5LnJlc3RvcmUoKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcGFzcyB0aGUgY29ycmVjdCBkYXRhIGZvciBzb2RpdW0gY3J5cHRvX3NpZ24nLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gYXdhaXQgVXNlclV0aWxzLmdldFVzZXJFRDI1NTE5S2V5UGFpcigpO1xuICAgICAgY29uc3QgcmVjaXBpZW50ID0gVGVzdFV0aWxzLmdlbmVyYXRlRmFrZVB1YktleSgpO1xuICAgICAgY29uc3Qgc29kaXVtID0gYXdhaXQgZ2V0U29kaXVtKCk7XG4gICAgICBjb25zdCBjcnlwdG9TaWduRGV0YWNoZWRTcHkgPSBzYW5kYm94U2Vzc2lvblByb3RvY29sLnNweShzb2RpdW0sICdjcnlwdG9fc2lnbl9kZXRhY2hlZCcpO1xuICAgICAgY29uc3QgcGxhaW5UZXh0ID0gJzEyMzQ1Nic7XG4gICAgICBjb25zdCBwbGFpblRleHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFN0cmluZ1V0aWxzLmVuY29kZShwbGFpblRleHQsICd1dGY4JykpO1xuICAgICAgY29uc3QgdXNlckVEMjU1MTlQdWJLZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZTogbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgIFN0cmluZ1V0aWxzLmZyb21IZXgoa2V5cGFpciEucHViS2V5KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlY2lwaWVudFgyNTUxOVB1YmxpY0tleVdpdGhvdXRQcmVmaXggPSBQdWJLZXkucmVtb3ZlMDVQcmVmaXhJZk5lZWRlZChyZWNpcGllbnQua2V5KTtcblxuICAgICAgY29uc3QgcmVjaXBpZW50WDI1NTE5UHVibGljS2V5ID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgIFN0cmluZ1V0aWxzLmZyb21IZXgocmVjaXBpZW50WDI1NTE5UHVibGljS2V5V2l0aG91dFByZWZpeClcbiAgICAgICk7XG4gICAgICBhd2FpdCBNZXNzYWdlRW5jcnlwdGVyLmVuY3J5cHRVc2luZ1Nlc3Npb25Qcm90b2NvbChyZWNpcGllbnQsIHBsYWluVGV4dEJ5dGVzKTtcbiAgICAgIGNvbnN0IFtkYXRhRm9yU2lnbiwgdXNlckVEMjU1MTlTZWNyZXRLZXlCeXRlc10gPSBjcnlwdG9TaWduRGV0YWNoZWRTcHkuYXJnc1swXTtcbiAgICAgIGNvbnN0IHVzZXJFZFByaXZrZXlCeXRlcyA9IG5ldyBVaW50OEFycmF5KFN0cmluZ1V0aWxzLmZyb21IZXgoa2V5cGFpciEucHJpdktleSkpO1xuICAgICAgZXhwZWN0KHVzZXJFRDI1NTE5U2VjcmV0S2V5Qnl0ZXMpLnRvLmVxdWFsQnl0ZXModXNlckVkUHJpdmtleUJ5dGVzKTtcbiAgICAgIC8vIGRhdGFGb3JTaWduIG11c3QgYmUgcGxhaW50ZXh0IHwgdXNlckVEMjU1MTlQdWJLZXlCeXRlcyB8IHJlY2lwaWVudFgyNTUxOVB1YmxpY0tleVxuICAgICAgZXhwZWN0KChkYXRhRm9yU2lnbiBhcyBVaW50OEFycmF5KS5zdWJhcnJheSgwLCBwbGFpblRleHRCeXRlcy5sZW5ndGgpKS50by5lcXVhbEJ5dGVzKFxuICAgICAgICBwbGFpblRleHRCeXRlc1xuICAgICAgKTtcbiAgICAgIGV4cGVjdChcbiAgICAgICAgKGRhdGFGb3JTaWduIGFzIFVpbnQ4QXJyYXkpLnN1YmFycmF5KFxuICAgICAgICAgIHBsYWluVGV4dEJ5dGVzLmxlbmd0aCxcbiAgICAgICAgICBwbGFpblRleHRCeXRlcy5sZW5ndGggKyB1c2VyRUQyNTUxOVB1YktleUJ5dGVzLmxlbmd0aFxuICAgICAgICApXG4gICAgICApLnRvLmVxdWFsQnl0ZXModXNlckVEMjU1MTlQdWJLZXlCeXRlcyk7XG5cbiAgICAgIC8vIHRoZSByZWNpcGllbnQgcHVia2V5IG11c3QgaGF2ZSBpdHMgMDUgcHJlZml4IHJlbW92ZWRcbiAgICAgIGV4cGVjdChcbiAgICAgICAgKGRhdGFGb3JTaWduIGFzIFVpbnQ4QXJyYXkpLnN1YmFycmF5KHBsYWluVGV4dEJ5dGVzLmxlbmd0aCArIHVzZXJFRDI1NTE5UHViS2V5Qnl0ZXMubGVuZ3RoKVxuICAgICAgKS50by5lcXVhbEJ5dGVzKHJlY2lwaWVudFgyNTUxOVB1YmxpY0tleSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiB2YWxpZCBkZWNvZGFibGUgY2lwaGVydGV4dCcsIGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGZvciB0ZXN0aW5nLCB3ZSBlbmNvZGUgYSBtZXNzYWdlIHRvIG91cnNlbGZcbiAgICAgIGNvbnN0IHVzZXJYMjU1MTlLZXlQYWlyID0gYXdhaXQgVXNlclV0aWxzLmdldElkZW50aXR5S2V5UGFpcigpO1xuICAgICAgY29uc3QgdXNlckVkMjU1MTlLZXlQYWlyID0gYXdhaXQgVXNlclV0aWxzLmdldFVzZXJFRDI1NTE5S2V5UGFpcigpO1xuXG4gICAgICBjb25zdCBwbGFpblRleHRCeXRlcyA9IG5ldyBVaW50OEFycmF5KFN0cmluZ1V0aWxzLmVuY29kZSgnMTIzNDU2Nzg5JywgJ3V0ZjgnKSk7XG5cbiAgICAgIGNvbnN0IHNvZGl1bSA9IGF3YWl0IGdldFNvZGl1bSgpO1xuXG4gICAgICBjb25zdCByZWNpcGllbnRYMjU1MTlQcml2YXRlS2V5ID0gdXNlclgyNTUxOUtleVBhaXIhLnByaXZLZXk7XG4gICAgICBjb25zdCByZWNpcGllbnRYMjU1MTlQdWJsaWNLZXlIZXggPSB0b0hleCh1c2VyWDI1NTE5S2V5UGFpciEucHViS2V5KTtcbiAgICAgIGNvbnN0IHJlY2lwaWVudFgyNTUxOVB1YmxpY0tleVdpdGhvdXRQcmVmaXggPSBQdWJLZXkucmVtb3ZlMDVQcmVmaXhJZk5lZWRlZChcbiAgICAgICAgcmVjaXBpZW50WDI1NTE5UHVibGljS2V5SGV4XG4gICAgICApO1xuICAgICAgY29uc3QgcmVjaXBpZW50WDI1NTE5UHVibGljS2V5ID0gbmV3IFB1YktleShyZWNpcGllbnRYMjU1MTlQdWJsaWNLZXlXaXRob3V0UHJlZml4KTtcbiAgICAgIGNvbnN0IGNpcGhlcnRleHQgPSBhd2FpdCBNZXNzYWdlRW5jcnlwdGVyLmVuY3J5cHRVc2luZ1Nlc3Npb25Qcm90b2NvbChcbiAgICAgICAgcmVjaXBpZW50WDI1NTE5UHVibGljS2V5LFxuICAgICAgICBwbGFpblRleHRCeXRlc1xuICAgICAgKTtcblxuICAgICAgLy8gZGVjcnlwdCBjb250ZW50XG4gICAgICBjb25zdCBwbGFpbnRleHRXaXRoTWV0YWRhdGEgPSBzb2RpdW0uY3J5cHRvX2JveF9zZWFsX29wZW4oXG4gICAgICAgIGNpcGhlcnRleHQsXG4gICAgICAgIG5ldyBVaW50OEFycmF5KGZyb21IZXgocmVjaXBpZW50WDI1NTE5UHVibGljS2V5LmtleSkpLFxuICAgICAgICBuZXcgVWludDhBcnJheShyZWNpcGllbnRYMjU1MTlQcml2YXRlS2V5KVxuICAgICAgKTtcblxuICAgICAgLy8gZ2V0IG1lc3NhZ2UgcGFydHNcbiAgICAgIGNvbnN0IHNpZ25hdHVyZVNpemUgPSBzb2RpdW0uY3J5cHRvX3NpZ25fQllURVM7XG4gICAgICBjb25zdCBlZDI1NTE5UHVibGljS2V5U2l6ZSA9IHNvZGl1bS5jcnlwdG9fc2lnbl9QVUJMSUNLRVlCWVRFUztcbiAgICAgIGNvbnN0IHNpZ25hdHVyZVN0YXJ0ID0gcGxhaW50ZXh0V2l0aE1ldGFkYXRhLmJ5dGVMZW5ndGggLSBzaWduYXR1cmVTaXplO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gcGxhaW50ZXh0V2l0aE1ldGFkYXRhLnN1YmFycmF5KHNpZ25hdHVyZVN0YXJ0KTtcbiAgICAgIGNvbnN0IHB1YmtleVN0YXJ0ID0gcGxhaW50ZXh0V2l0aE1ldGFkYXRhLmJ5dGVMZW5ndGggLSAoc2lnbmF0dXJlU2l6ZSArIGVkMjU1MTlQdWJsaWNLZXlTaXplKTtcbiAgICAgIGNvbnN0IHB1YmtleUVuZCA9IHBsYWludGV4dFdpdGhNZXRhZGF0YS5ieXRlTGVuZ3RoIC0gc2lnbmF0dXJlU2l6ZTtcbiAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIG91cnMgZWQyNTUxOSBwdWJrZXlcbiAgICAgIGNvbnN0IHNlbmRlckVEMjU1MTlQdWJsaWNLZXkgPSBwbGFpbnRleHRXaXRoTWV0YWRhdGEuc3ViYXJyYXkocHVia2V5U3RhcnQsIHB1YmtleUVuZCk7XG5cbiAgICAgIGNvbnN0IHBsYWluVGV4dEVuZCA9XG4gICAgICAgIHBsYWludGV4dFdpdGhNZXRhZGF0YS5ieXRlTGVuZ3RoIC0gKHNpZ25hdHVyZVNpemUgKyBlZDI1NTE5UHVibGljS2V5U2l6ZSk7XG4gICAgICBjb25zdCBwbGFpbnRleHREZWNvZGVkID0gcGxhaW50ZXh0V2l0aE1ldGFkYXRhLnN1YmFycmF5KDAsIHBsYWluVGV4dEVuZCk7XG5cbiAgICAgIGV4cGVjdChwbGFpbnRleHREZWNvZGVkKS50by5lcXVhbEJ5dGVzKHBsYWluVGV4dEJ5dGVzKTtcbiAgICAgIGV4cGVjdChzZW5kZXJFRDI1NTE5UHVibGljS2V5KS50by5lcXVhbEJ5dGVzKHVzZXJFZDI1NTE5S2V5UGFpciEucHViS2V5KTtcblxuICAgICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgaXMgdmFsaWRcbiAgICAgIGNvbnN0IGRhdGFGb3JWZXJpZnkgPSBjb25jYXRVSW50OEFycmF5KFxuICAgICAgICBwbGFpbnRleHREZWNvZGVkLFxuICAgICAgICBzZW5kZXJFRDI1NTE5UHVibGljS2V5LFxuICAgICAgICBuZXcgVWludDhBcnJheShmcm9tSGV4KHJlY2lwaWVudFgyNTUxOVB1YmxpY0tleS5rZXkpKVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGlzVmFsaWQgPSBzb2RpdW0uY3J5cHRvX3NpZ25fdmVyaWZ5X2RldGFjaGVkKFxuICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgIGRhdGFGb3JWZXJpZnksXG4gICAgICAgIHNlbmRlckVEMjU1MTlQdWJsaWNLZXlcbiAgICAgICk7XG4gICAgICBleHBlY3QoaXNWYWxpZCkudG8uYmUuZXF1YWwodHJ1ZSwgJ3RoZSBzaWduYXR1cmUgY2Fubm90IGJlIHZlcmlmaWVkJyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrQkFBNkI7QUFDN0IsYUFBd0I7QUFDeEIsWUFBdUI7QUFDdkIsb0JBQThEO0FBQzlELDRCQUErQjtBQUMvQix3QkFBMEI7QUFDMUIsc0JBQThCO0FBRTlCLG1CQUF1QztBQUV2Qyx3QkFBc0I7QUFDdEIsbUJBQXVCO0FBQ3ZCLG9CQUErQjtBQUMvQiwyQkFBa0M7QUFFbEMsb0JBQUssSUFBSSx5QkFBUztBQUdsQixTQUFTLG9CQUFvQixNQUFNO0FBQ2pDLFFBQU0sVUFBVSxNQUFNLGNBQWM7QUFDcEMsUUFBTSxZQUFZO0FBQ2xCLFFBQU0sd0JBQXdCO0FBQUEsSUFDNUIsUUFBUTtBQUFBLElBQ1IsU0FDRTtBQUFBLEVBQ0o7QUFFQSxRQUFNLHFCQUFxQjtBQUFBLElBQ3pCLFFBQVEsSUFBSSxXQUFXO0FBQUEsTUFDckI7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNB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
